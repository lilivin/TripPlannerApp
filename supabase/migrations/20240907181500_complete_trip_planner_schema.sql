-- Migration: Complete TripPlanner Schema Implementation
-- Purpose: Creates the full database schema for the TripPlanner application including all tables, 
-- relationships, indexes and security policies as defined in the schema plan.
-- Author: Generated by AI Assistant
-- Date: 2024-09-07

-- enable postgis extension for geographical data
create extension if not exists postgis;

-- enable pgcrypto for gen_random_uuid()
create extension if not exists pgcrypto;

-- ===========================================
-- TABLE DEFINITIONS
-- ===========================================

-- users table (if not already created)
create table if not exists users (
  id uuid primary key default gen_random_uuid(),
  email varchar(255) not null unique,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null,
  language_preference varchar(10) default 'pl' not null,
  last_login_at timestamp with time zone,
  is_active boolean default true not null,
  avatar_url text,
  display_name varchar(100),
  deleted_at timestamp with time zone,
  is_admin boolean default false not null
);

alter table users enable row level security;

-- creators table (if not already created)
create table if not exists creators (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references users(id),
  display_name varchar(100) not null,
  biography text,
  profile_image_url text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null,
  is_verified boolean default false not null,
  contact_email varchar(255),
  website text,
  deleted_at timestamp with time zone
);

-- Create a partial unique index instead of a constraint with WHERE clause
create unique index if not exists idx_creators_user_id_unique on creators(user_id) where deleted_at is null;

alter table creators enable row level security;

-- guides table (if not already created)
create table if not exists guides (
  id uuid primary key default gen_random_uuid(),
  creator_id uuid not null references creators(id),
  title varchar(255) not null,
  description text not null,
  language varchar(10) default 'pl' not null,
  price decimal(10, 2) default 0.00 not null,
  is_published boolean default false not null,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null,
  version integer default 1 not null,
  cover_image_url text,
  location_name varchar(255) not null,
  recommended_days integer default 1 not null,
  deleted_at timestamp with time zone
);

alter table guides enable row level security;

-- attractions table (if not already created)
create table if not exists attractions (
  id uuid primary key default gen_random_uuid(),
  name varchar(255) not null,
  description text not null,
  address text not null,
  geolocation geography(point) not null,
  opening_hours jsonb,
  contact_info jsonb,
  images jsonb default '[]'::jsonb not null,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null,
  creator_id uuid not null references creators(id),
  average_visit_time_minutes integer,
  ticket_price_info text,
  accessibility_info text,
  deleted_at timestamp with time zone
);

alter table attractions enable row level security;

-- guide_attractions junction table
create table if not exists guide_attractions (
  guide_id uuid not null references guides(id),
  attraction_id uuid not null references attractions(id),
  order_index integer not null,
  custom_description text,
  is_highlight boolean default false not null,
  created_at timestamp with time zone default now() not null,
  primary key (guide_id, attraction_id)
);

alter table guide_attractions enable row level security;

-- tags table
create table if not exists tags (
  id uuid primary key default gen_random_uuid(),
  name varchar(100) not null,
  category varchar(50) not null check (category in ('Cultural', 'Fun_Facts', 'Historical', 'Culinary')),
  created_at timestamp with time zone default now() not null,
  unique(name, category)
);

alter table tags enable row level security;

-- attraction_tags junction table
create table if not exists attraction_tags (
  attraction_id uuid not null references attractions(id),
  tag_id uuid not null references tags(id),
  created_at timestamp with time zone default now() not null,
  primary key (attraction_id, tag_id)
);

alter table attraction_tags enable row level security;

-- plans table
create table if not exists plans (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references users(id),
  guide_id uuid not null references guides(id),
  name varchar(255) not null,
  content jsonb not null,
  generation_params jsonb not null,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null,
  ai_generation_cost decimal(10, 6),
  is_favorite boolean default false not null,
  deleted_at timestamp with time zone
);

alter table plans enable row level security;

-- user_guide_access junction table
create table if not exists user_guide_access (
  user_id uuid not null references users(id),
  guide_id uuid not null references guides(id),
  access_type varchar(20) not null check (access_type in ('free', 'purchased', 'subscription')),
  granted_at timestamp with time zone default now() not null,
  expires_at timestamp with time zone,
  payment_id text,
  primary key (user_id, guide_id)
);

alter table user_guide_access enable row level security;

-- reviews table
create table if not exists reviews (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references users(id),
  guide_id uuid not null references guides(id),
  rating integer not null check (rating between 1 and 5),
  comment text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null,
  is_visible boolean default true not null
);

-- Create a partial unique index for reviews
create unique index if not exists idx_reviews_user_guide_unique on reviews(user_id, guide_id) where is_visible = true;

alter table reviews enable row level security;

-- offline_cache_status junction table
create table if not exists offline_cache_status (
  user_id uuid not null references users(id),
  plan_id uuid not null references plans(id),
  is_cached boolean default false not null,
  last_synced_at timestamp with time zone default now() not null,
  primary key (user_id, plan_id)
);

alter table offline_cache_status enable row level security;

-- user_guide_interactions junction table
create table if not exists user_guide_interactions (
  user_id uuid not null references users(id),
  guide_id uuid not null references guides(id),
  interaction_type varchar(50) not null check (interaction_type in ('view', 'detailed_view', 'bookmark', 'generate_plan', 'purchase')),
  created_at timestamp with time zone default now() not null,
  last_interaction_at timestamp with time zone default now() not null,
  interaction_count integer default 1 not null,
  primary key (user_id, guide_id, interaction_type)
);

alter table user_guide_interactions enable row level security;

-- ===========================================
-- INDEXES
-- ===========================================

-- users indexes
create index if not exists idx_users_email on users(email);
create index if not exists idx_users_deleted_at on users(deleted_at) where deleted_at is null;

-- guides indexes
create index if not exists idx_guides_creator_id on guides(creator_id);
create index if not exists idx_guides_is_published on guides(is_published) where is_published = true;
create index if not exists idx_guides_language on guides(language);
create index if not exists idx_guides_created_at on guides(created_at);
create index if not exists idx_guides_deleted_at on guides(deleted_at) where deleted_at is null;

-- attractions indexes
create index if not exists idx_attractions_creator_id on attractions(creator_id);
create index if not exists idx_attractions_deleted_at on attractions(deleted_at) where deleted_at is null;
create index if not exists idx_attractions_geolocation on attractions using gist (geolocation);
create index if not exists idx_attractions_opening_hours on attractions using gin (opening_hours);
create index if not exists idx_attractions_contact_info on attractions using gin (contact_info);
create index if not exists idx_attractions_images on attractions using gin (images);

-- plans indexes
create index if not exists idx_plans_user_id on plans(user_id);
create index if not exists idx_plans_guide_id on plans(guide_id);
create index if not exists idx_plans_created_at on plans(created_at);
create index if not exists idx_plans_is_favorite on plans(is_favorite) where is_favorite = true;
create index if not exists idx_plans_deleted_at on plans(deleted_at) where deleted_at is null;
create index if not exists idx_plans_content on plans using gin (content);
create index if not exists idx_plans_generation_params on plans using gin (generation_params);

-- reviews indexes
create index if not exists idx_reviews_guide_id on reviews(guide_id);
create index if not exists idx_reviews_rating on reviews(rating);

-- user_guide_interactions indexes
create index if not exists idx_user_guide_interactions_user_id on user_guide_interactions(user_id);
create index if not exists idx_user_guide_interactions_guide_id on user_guide_interactions(guide_id);
create index if not exists idx_user_guide_interactions_last_interaction on user_guide_interactions(last_interaction_at);
create index if not exists idx_user_guide_interactions_type on user_guide_interactions(interaction_type);

-- ===========================================
-- ROW LEVEL SECURITY POLICIES
-- ===========================================

-- users table policies
create policy "users_select_anon" on users
    for select to anon
    using (false);

create policy "users_select_auth" on users
    for select to authenticated
    using (auth.uid() = id);

create policy "users_insert_anon" on users
    for insert to anon
    with check (false);

create policy "users_insert_auth" on users
    for insert to authenticated
    with check (auth.uid() = id);

create policy "users_update_anon" on users
    for update to anon
    using (false)
    with check (false);

create policy "users_update_auth" on users
    for update to authenticated
    using (auth.uid() = id)
    with check (auth.uid() = id);

create policy "users_delete_anon" on users
    for delete to anon
    using (false);

create policy "users_delete_auth" on users
    for delete to authenticated
    using (auth.uid() = id);

-- creators table policies
create policy "creators_select_anon" on creators
    for select to anon
    using (deleted_at is null);

create policy "creators_select_auth" on creators
    for select to authenticated
    using (deleted_at is null);

create policy "creators_insert_anon" on creators
    for insert to anon
    with check (false);

create policy "creators_insert_auth" on creators
    for insert to authenticated
    with check (auth.uid() = user_id);

create policy "creators_update_anon" on creators
    for update to anon
    using (false)
    with check (false);

create policy "creators_update_auth" on creators
    for update to authenticated
    using (auth.uid() = user_id)
    with check (auth.uid() = user_id);

create policy "creators_delete_anon" on creators
    for delete to anon
    using (false);

create policy "creators_delete_auth" on creators
    for delete to authenticated
    using (auth.uid() = user_id);

-- guides table policies
create policy "guides_select_anon" on guides
    for select to anon
    using (is_published = true and deleted_at is null);

create policy "guides_select_auth" on guides
    for select to authenticated
    using (
        is_published = true 
        or id in (
            select guide_id from user_guide_access
            where user_id = auth.uid()
            and (expires_at is null or expires_at > now())
        )
        or auth.uid() in (
            select user_id from creators where id = creator_id
        )
    );

create policy "guides_insert_anon" on guides
    for insert to anon
    with check (false);

create policy "guides_insert_auth" on guides
    for insert to authenticated
    with check (auth.uid() in (
        select user_id from creators where id = creator_id
    ));

create policy "guides_update_anon" on guides
    for update to anon
    using (false)
    with check (false);

create policy "guides_update_auth" on guides
    for update to authenticated
    using (auth.uid() in (select user_id from creators where id = creator_id))
    with check (auth.uid() in (select user_id from creators where id = creator_id));

create policy "guides_delete_anon" on guides
    for delete to anon
    using (false);

create policy "guides_delete_auth" on guides
    for delete to authenticated
    using (auth.uid() in (select user_id from creators where id = creator_id));

-- attractions table policies
create policy "attractions_select_anon" on attractions
    for select to anon
    using (
        deleted_at is null 
        and id in (
            select attraction_id from guide_attractions
            where guide_id in (
                select id from guides 
                where is_published = true 
                and deleted_at is null
            )
        )
    );

create policy "attractions_select_auth" on attractions
    for select to authenticated
    using (
        deleted_at is null 
        and (
            id in (
                select attraction_id from guide_attractions
                where guide_id in (
                    select id from guides 
                    where is_published = true 
                    and deleted_at is null
                )
            )
            or auth.uid() in (
                select user_id from creators 
                where id = creator_id
            )
        )
    );

create policy "attractions_insert_anon" on attractions
    for insert to anon
    with check (false);

create policy "attractions_insert_auth" on attractions
    for insert to authenticated
    with check (auth.uid() in (
        select user_id from creators 
        where id = creator_id
    ));

create policy "attractions_update_anon" on attractions
    for update to anon
    using (false)
    with check (false);

create policy "attractions_update_auth" on attractions
    for update to authenticated
    using (auth.uid() in (select user_id from creators where id = creator_id))
    with check (auth.uid() in (select user_id from creators where id = creator_id));

create policy "attractions_delete_anon" on attractions
    for delete to anon
    using (false);

create policy "attractions_delete_auth" on attractions
    for delete to authenticated
    using (auth.uid() in (select user_id from creators where id = creator_id));

-- guide_attractions junction table policies
create policy "guide_attractions_select_anon" on guide_attractions
    for select to anon
    using (
        guide_id in (
            select id from guides 
            where is_published = true 
            and deleted_at is null
        )
    );

create policy "guide_attractions_select_auth" on guide_attractions
    for select to authenticated
    using (
        guide_id in (
            select id from guides 
            where is_published = true 
            and deleted_at is null
        )
        or guide_id in (
            select id from guides
            where auth.uid() in (
                select user_id from creators 
                where id = creator_id
            )
        )
    );

create policy "guide_attractions_insert_anon" on guide_attractions
    for insert to anon
    with check (false);

create policy "guide_attractions_insert_auth" on guide_attractions
    for insert to authenticated
    with check (
        guide_id in (
            select id from guides
            where auth.uid() in (
                select user_id from creators 
                where id = creator_id
            )
        )
    );

create policy "guide_attractions_update_anon" on guide_attractions
    for update to anon
    using (false)
    with check (false);

create policy "guide_attractions_update_auth" on guide_attractions
    for update to authenticated
    using (
        guide_id in (
            select id from guides
            where auth.uid() in (
                select user_id from creators 
                where id = creator_id
            )
        )
    )
    with check (
        guide_id in (
            select id from guides
            where auth.uid() in (
                select user_id from creators 
                where id = creator_id
            )
        )
    );

create policy "guide_attractions_delete_anon" on guide_attractions
    for delete to anon
    using (false);

create policy "guide_attractions_delete_auth" on guide_attractions
    for delete to authenticated
    using (
        guide_id in (
            select id from guides
            where auth.uid() in (
                select user_id from creators 
                where id = creator_id
            )
        )
    );

-- tags table policies
create policy "tags_select_anon" on tags
    for select to anon
    using (true);

create policy "tags_select_auth" on tags
    for select to authenticated
    using (true);

create policy "tags_insert_anon" on tags
    for insert to anon
    with check (false);

create policy "tags_insert_auth" on tags
    for insert to authenticated
    with check (false);

create policy "tags_update_anon" on tags
    for update to anon
    using (false)
    with check (false);

create policy "tags_update_auth" on tags
    for update to authenticated
    using (false)
    with check (false);

create policy "tags_delete_anon" on tags
    for delete to anon
    using (false);

create policy "tags_delete_auth" on tags
    for delete to authenticated
    using (false);

-- attraction_tags junction table policies
create policy "attraction_tags_select_anon" on attraction_tags
    for select to anon
    using (true);

create policy "attraction_tags_select_auth" on attraction_tags
    for select to authenticated
    using (true);

create policy "attraction_tags_insert_anon" on attraction_tags
    for insert to anon
    with check (false);

create policy "attraction_tags_insert_auth" on attraction_tags
    for insert to authenticated
    with check (
        attraction_id in (
            select id from attractions
            where auth.uid() in (
                select user_id from creators 
                where id = creator_id
            )
        )
    );

create policy "attraction_tags_delete_anon" on attraction_tags
    for delete to anon
    using (false);

create policy "attraction_tags_delete_auth" on attraction_tags
    for delete to authenticated
    using (
        attraction_id in (
            select id from attractions
            where auth.uid() in (
                select user_id from creators 
                where id = creator_id
            )
        )
    );

-- plans table policies
create policy "plans_select_anon" on plans
    for select to anon
    using (false);

create policy "plans_select_auth" on plans
    for select to authenticated
    using (auth.uid() = user_id and deleted_at is null);

create policy "plans_insert_anon" on plans
    for insert to anon
    with check (false);

create policy "plans_insert_auth" on plans
    for insert to authenticated
    with check (auth.uid() = user_id);

create policy "plans_update_anon" on plans
    for update to anon
    using (false)
    with check (false);

create policy "plans_update_auth" on plans
    for update to authenticated
    using (auth.uid() = user_id)
    with check (auth.uid() = user_id);

create policy "plans_delete_anon" on plans
    for delete to anon
    using (false);

create policy "plans_delete_auth" on plans
    for delete to authenticated
    using (auth.uid() = user_id);

-- user_guide_access junction table policies
create policy "user_guide_access_select_anon" on user_guide_access
    for select to anon
    using (false);

create policy "user_guide_access_select_auth" on user_guide_access
    for select to authenticated
    using (
        auth.uid() = user_id
        or auth.uid() in (
            select user_id from creators 
            where id in (
                select creator_id from guides 
                where id = guide_id
            )
        )
    );

create policy "user_guide_access_insert_anon" on user_guide_access
    for insert to anon
    with check (false);

create policy "user_guide_access_insert_auth" on user_guide_access
    for insert to authenticated
    with check (auth.uid() = user_id);

create policy "user_guide_access_update_anon" on user_guide_access
    for update to anon
    using (false)
    with check (false);

create policy "user_guide_access_update_auth" on user_guide_access
    for update to authenticated
    using (false)
    with check (false);

create policy "user_guide_access_delete_anon" on user_guide_access
    for delete to anon
    using (false);

create policy "user_guide_access_delete_auth" on user_guide_access
    for delete to authenticated
    using (false);

-- reviews table policies
create policy "reviews_select_anon" on reviews
    for select to anon
    using (is_visible = true);

create policy "reviews_select_auth" on reviews
    for select to authenticated
    using (
        is_visible = true
        or auth.uid() = user_id
        or auth.uid() in (
            select user_id from creators 
            where id in (
                select creator_id from guides 
                where id = guide_id
            )
        )
    );

create policy "reviews_insert_anon" on reviews
    for insert to anon
    with check (false);

create policy "reviews_insert_auth" on reviews
    for insert to authenticated
    with check (auth.uid() = user_id);

create policy "reviews_update_anon" on reviews
    for update to anon
    using (false)
    with check (false);

create policy "reviews_update_auth" on reviews
    for update to authenticated
    using (auth.uid() = user_id)
    with check (auth.uid() = user_id);

create policy "reviews_delete_anon" on reviews
    for delete to anon
    using (false);

create policy "reviews_delete_auth" on reviews
    for delete to authenticated
    using (auth.uid() = user_id);

-- offline_cache_status junction table policies
create policy "offline_cache_status_select_anon" on offline_cache_status
    for select to anon
    using (false);

create policy "offline_cache_status_select_auth" on offline_cache_status
    for select to authenticated
    using (auth.uid() = user_id);

create policy "offline_cache_status_insert_anon" on offline_cache_status
    for insert to anon
    with check (false);

create policy "offline_cache_status_insert_auth" on offline_cache_status
    for insert to authenticated
    with check (
        auth.uid() = user_id 
        and plan_id in (
            select id from plans 
            where user_id = auth.uid()
        )
    );

create policy "offline_cache_status_update_anon" on offline_cache_status
    for update to anon
    using (false)
    with check (false);

create policy "offline_cache_status_update_auth" on offline_cache_status
    for update to authenticated
    using (auth.uid() = user_id)
    with check (auth.uid() = user_id);

create policy "offline_cache_status_delete_anon" on offline_cache_status
    for delete to anon
    using (false);

create policy "offline_cache_status_delete_auth" on offline_cache_status
    for delete to authenticated
    using (auth.uid() = user_id);

-- user_guide_interactions junction table policies
create policy "user_guide_interactions_select_anon" on user_guide_interactions
    for select to anon
    using (false);

create policy "user_guide_interactions_select_auth" on user_guide_interactions
    for select to authenticated
    using (
        auth.uid() = user_id
        or auth.uid() in (
            select user_id from creators 
            where id in (
                select creator_id from guides 
                where id = guide_id
            )
        )
    );

create policy "user_guide_interactions_insert_anon" on user_guide_interactions
    for insert to anon
    with check (false);

create policy "user_guide_interactions_insert_auth" on user_guide_interactions
    for insert to authenticated
    with check (auth.uid() = user_id);

create policy "user_guide_interactions_update_anon" on user_guide_interactions
    for update to anon
    using (false)
    with check (false);

create policy "user_guide_interactions_update_auth" on user_guide_interactions
    for update to authenticated
    using (auth.uid() = user_id)
    with check (auth.uid() = user_id);

create policy "user_guide_interactions_delete_anon" on user_guide_interactions
    for delete to anon
    using (false);

create policy "user_guide_interactions_delete_auth" on user_guide_interactions
    for delete to authenticated
    using (auth.uid() = user_id);

-- set up triggers for updated_at columns
create or replace function update_modified_column()
returns trigger as $$
begin
    new.updated_at = now();
    return new;
end;
$$ language 'plpgsql';

-- Create triggers conditionally (checking if they exist first)
do $$
begin
    -- users trigger
    if not exists (select 1 from pg_trigger where tgname = 'update_users_updated_at') then
        create trigger update_users_updated_at
        before update on users
        for each row
        execute procedure update_modified_column();
    end if;
    
    -- creators trigger
    if not exists (select 1 from pg_trigger where tgname = 'update_creators_updated_at') then
        create trigger update_creators_updated_at
        before update on creators
        for each row
        execute procedure update_modified_column();
    end if;
    
    -- guides trigger
    if not exists (select 1 from pg_trigger where tgname = 'update_guides_updated_at') then
        create trigger update_guides_updated_at
        before update on guides
        for each row
        execute procedure update_modified_column();
    end if;
    
    -- attractions trigger
    if not exists (select 1 from pg_trigger where tgname = 'update_attractions_updated_at') then
        create trigger update_attractions_updated_at
        before update on attractions
        for each row
        execute procedure update_modified_column();
    end if;
    
    -- plans trigger
    if not exists (select 1 from pg_trigger where tgname = 'update_plans_updated_at') then
        create trigger update_plans_updated_at
        before update on plans
        for each row
        execute procedure update_modified_column();
    end if;
    
    -- reviews trigger
    if not exists (select 1 from pg_trigger where tgname = 'update_reviews_updated_at') then
        create trigger update_reviews_updated_at
        before update on reviews
        for each row
        execute procedure update_modified_column();
    end if;
end
$$; 